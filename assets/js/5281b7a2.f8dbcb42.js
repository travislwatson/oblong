(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[927],{9870:function(e,t,i){"use strict";i.r(t),i.d(t,{frontMatter:function(){return s},metadata:function(){return l},toc:function(){return c},default:function(){return d}});var a=i(2122),n=i(9756),r=(i(7294),i(3905)),o=["components"],s={sidebar_position:2,sidebar_label:"Architecture"},l={unversionedId:"architecture",id:"architecture",isDocsHomePage:!1,title:'Architecture: the "Heart" of Oblong',description:"A less catchy name for Oblong's architecture might be CQSV: Command + Query + State + View.",source:"@site/docs/architecture.md",sourceDirName:".",slug:"/architecture",permalink:"/oblong/docs/architecture",editUrl:"https://github.com/travislwatson/oblong/edit/master/website/docs/architecture.md",version:"current",sidebar_label:"Architecture",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Architecture"},sidebar:"tutorialSidebar",previous:{title:"Quick Start",permalink:"/oblong/docs/quick-start"},next:{title:"Apps",permalink:"/oblong/docs/core/apps"}},c=[{value:"Inspiration",id:"inspiration",children:[]},{value:"Paths",id:"paths",children:[{value:"Reactive Path",id:"reactive-path",children:[]},{value:"Interactive Path",id:"interactive-path",children:[]}]}],u={toc:c};function d(e){var t=e.components,i=(0,n.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A less catchy name for Oblong's architecture might be CQSV: Command + Query + State + View."),(0,r.kt)("h2",{id:"inspiration"},"Inspiration"),(0,r.kt)("p",null,"Heart is a one way architecture, using Flux as a foundation. Heart separates input and output flows from a fundamental level, borrowing the C and Q from CQRS. Heart embraces declarative presentation, borrowing the V from MVC. And lastly Heart loves React's atomic ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," tuple implementation and its throwback to functional lenses."),(0,r.kt)("p",null,"Heart attempts to combine these wonderful powerhouses to provide an intuitive framework for building developer friendly applications."),(0,r.kt)("h2",{id:"paths"},"Paths"),(0,r.kt)("p",null,"While you as a developer will interact with the four building blocks in Heart, the more important concept is the dynamic between reactivity and interactivity:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Reactive Path")," starts with a State observation, is transformed through a hierarchy of Queries, and is manifested through a reactive View render."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("strong",{parentName:"li"},"Interactive Path")," starts with some View interaction, chains into any combination of Commands, and ultimately ends up mutating state.")),(0,r.kt)("h3",{id:"reactive-path"},"Reactive Path"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"State > Query > View\n")),(0,r.kt)("p",null,"Every piece of State is an atomic observable unit. Queries can use these atoms as well as other Queries to create a hierarchy of derivations with chained reactivity. The View then only needs to declare the final pieces it uses, and the hierarchy of reactivity will ensure the View is re-rendered when it should, and never when it shouldn't."),(0,r.kt)("p",null,"State should be minimal and normalized: store only the essence."),(0,r.kt)("p",null,"Views should be lifeless and derivative, products of their arguments. Introduce View boundaries as frequently as you're comfortable since it increases performance by reducing your re-render blast radiuses."),(0,r.kt)("p",null,"Queries are your solution for reactive code organization. These create performance optimization boundaries for your framework to utilize, and code organization boundaries for developer sanity."),(0,r.kt)("h3",{id:"interactive-path"},"Interactive Path"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"View > Command > State\n")),(0,r.kt)("p",null,"While the Reactive Path seems to work by magic, the complimentary Interactive Path is equally as important as it is different. Instead of attempting to be declarative, pure, or reactive, the Interactive Path embraces the reality: it deals with asynchronicity, side effects, branching, and ultimately State mutations. It fits a procedural style of programming."),(0,r.kt)("p",null,"Views should eliminate all but the bare essentials of interactivity: minimal event handling and argument binding, leaving as much work as possible for the Commands. Views should never pass information to Commands that they can fetch themselves. Instead only pass execution context information."),(0,r.kt)("p",null,"State mutations should be atomic and immutable to minimize the computational overhead of change detection. To combine multiple logical State mutations within a single interaction, use a wrapping Command."),(0,r.kt)("p",null,"Commands are your solution for interactive code organization. Introduce Command boundaries wherever it will improve code organization, testability, or debugability."),(0,r.kt)("p",null,"When implementing dependency injection in Commands and Views, it's paramount to ensure State values and Query results are live and are never materialized. Breaking the reactivity link will make your code feel unpredictable."))}d.isMDXComponent=!0}}]);