(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[992],{5106:function(e,n,o){"use strict";o.r(n),o.d(n,{frontMatter:function(){return s},metadata:function(){return d},toc:function(){return u},default:function(){return m}});var t=o(2122),i=o(9756),a=(o(7294),o(3905)),r=["components"],s={sidebar_position:2},d={unversionedId:"core/commands",id:"core/commands",isDocsHomePage:!1,title:"Commands",description:'Commands are your "do-ers." They are always triggered from some action, such as a user event or api response or even a simple timeout. All your interactions with the outside world should be here. They are composable, so err on making them too small.',source:"@site/docs/core/commands.md",sourceDirName:"core",slug:"/core/commands",permalink:"/oblong/docs/core/commands",editUrl:"https://github.com/travislwatson/oblong/edit/master/website/docs/core/commands.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Apps",permalink:"/oblong/docs/core/apps"},next:{title:"Queries",permalink:"/oblong/docs/core/queries"}},u=[{value:"Syntax",id:"syntax",children:[{value:"Command Name Duplication",id:"command-name-duplication",children:[]},{value:"Dependencies",id:"dependencies",children:[]},{value:"Command Body",id:"command-body",children:[]}]},{value:"Subscriptions",id:"subscriptions",children:[]},{value:"Unit Testing",id:"unit-testing",children:[]}],l={toc:u};function m(e){var n=e.components,o=(0,i.Z)(e,r);return(0,a.kt)("wrapper",(0,t.Z)({},l,o,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'Commands are your "do-ers." They are always triggered from some action, such as a user event or api response or even a simple timeout. All your interactions with the outside world should be here. They are composable, so err on making them too small.'),(0,a.kt)("h2",{id:"syntax"},"Syntax"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const myCommand = O.command('myCommand')\n  .with({ your, dependencies, here })\n  .as((o) => {\n    // Your work goes here\n  })\n")),(0,a.kt)("h3",{id:"command-name-duplication"},"Command Name Duplication"),(0,a.kt)("p",null,"In the above example, you see ",(0,a.kt)("inlineCode",{parentName:"p"},"myCommand")," twice, so you might want to eliminate the duplication. The string version supplied to the ",(0,a.kt)("inlineCode",{parentName:"p"},"O.command(...)")," function is indeed optional; this is perfectly valid: ",(0,a.kt)("inlineCode",{parentName:"p"},"O.command()"),"."),(0,a.kt)("p",null,"But you still probably want to use it."),(0,a.kt)("p",null,"Here's why: unlike some other Redux libraries like thunks, commands automatically emit actions for you to inspect call orders of your commands. This string name is used for these actions. That means your debugging experience will be significantly worse without them."),(0,a.kt)("h3",{id:"dependencies"},"Dependencies"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},".with({ ... })")," call allows you to specify any dependencies your command has. These dependencies will be available as properties on the first argument supplied to your command body."),(0,a.kt)("h3",{id:"command-body"},"Command Body"),(0,a.kt)("p",null,'Your command body is just a function with a special first argument: "little o." This special first argument will contain resolved versions of whatever dependencies you specify. Your command body can do about anything except directly trigger a re-render (the end result of your commands would need to trigger a state change which would trigger a reactive re-render). Commands are your Oblong workhorse!'),(0,a.kt)("h4",{id:"extra-arguments"},"Extra Arguments"),(0,a.kt)("p",null,"If your command can inject its dependencies, it should. But some things will require an argument or two. Commands support this out of the box, just take extra arguments after Little o:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const doSomething = O.command('doSomething')\n  .with({ count })\n  .as((o, howManyToAdd: number) => {\n    o.count = o.count + howManyToAdd\n  })\n\n// Call like: o.incrementCount(1)\n")),(0,a.kt)("p",null,"There's no opportunity for type inference here unfortunately: you'll need to explicitly type your command arguments."),(0,a.kt)("h4",{id:"return-value"},"Return Value"),(0,a.kt)("p",null,"Normally your commands will cause some side effect or a state change. Sometimes, however, it can be useful for them to return information instead of (or in addition to) side effects. Your intuition should be correct here: you can return as you would from any normal function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const doSomething = O.command('doSomething')\n  .with({ count })\n  .as((o): string => {\n    o.count = o.count + 1\n    return `${o.count} is new count.`\n  })\n")),(0,a.kt)("p",null,"While type inference would have worked in this case, it won't always work. Explicit return types are recommended whenever the command's return value is significant."),(0,a.kt)("h2",{id:"subscriptions"},"Subscriptions"),(0,a.kt)("p",null,"TODO"),(0,a.kt)("h2",{id:"unit-testing"},"Unit Testing"),(0,a.kt)("p",null,"TODO"))}m.isMDXComponent=!0}}]);